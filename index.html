<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Sticker Creator ‚Äî Simple</title>

<!-- Fuentes para textos de sticker -->
<link href="https://fonts.googleapis.com/css2?family=Luckiest+Guy&family=Permanent+Marker&family=Baloo+2:wght@700&family=Fredoka:wght@700&family=Bungee&family=Comic+Neue:wght@700&display=swap" rel="stylesheet">

<style>
  :root{
    --size:512px;
    --brand:#0ea5e9; --brand2:#22d3ee;
    --ok:#22c55e; --warn:#f59e0b; --danger:#ef4444;
    --stage-bg:#ffffff; --stage-bd:#e6eaf3;
  }
  *{box-sizing:border-box}
  html,body{margin:0}
  body{
    font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    color:#0b1020;
    /* Fondo colorido fuera del lienzo */
    background:
      radial-gradient(1100px 600px at 80% -10%, rgba(34,211,238,.18), transparent 60%),
      radial-gradient(800px 500px at 10% -20%, rgba(14,165,233,.22), transparent 50%),
      linear-gradient(180deg,#0c1229 0%, #0b1020 50%, #0a0f1e 100%);
    min-height:100vh;
  }
  .shell{max-width:960px; margin:24px auto; padding:0 16px}

  /* Barra superior con solo botones */
  .topbar{
    display:flex; gap:8px; align-items:center; justify-content:center;
    background:rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.12);
    border-radius:18px; padding:10px 12px; backdrop-filter: blur(6px);
    color:#e9f1ff; flex-wrap:wrap;
  }
  .btn{
    display:inline-flex; align-items:center; gap:8px;
    border:none; border-radius:12px; padding:10px 14px; font-weight:800; cursor:pointer;
    box-shadow:0 8px 20px rgba(2,8,23,.25);
    user-select:none;
  }
  .btn.ghost{background:#0e1733; color:#e7efff; border:1px solid rgba(255,255,255,.14); box-shadow:none}
  .btn.primary{background:linear-gradient(90deg, var(--brand), var(--brand2)); color:#00121a}
  .btn.ok{background:linear-gradient(90deg, var(--ok), #86efac); color:#052914}
  .btn.warn{background:linear-gradient(90deg, var(--warn), #fde68a); color:#231a05}
  .btn.danger{background:linear-gradient(90deg, var(--danger), #fca5a5); color:#2a0101}
  .btn:disabled{opacity:.6; cursor:not-allowed}

  /* Lienzo blanco centrado */
  .stage-wrap{display:grid; place-items:center; margin-top:16px}
  #stage{
    width:var(--size); height:var(--size); max-width:100%; aspect-ratio:1/1;
    position:relative; border-radius:20px; overflow:hidden;
    background:var(--stage-bg);
    border:2px solid var(--stage-bd);
    box-shadow:0 12px 34px rgba(2,8,23,.35);
    user-select:none; touch-action:none;
  }
  #checker{position:absolute; inset:0; background:
      conic-gradient(#e5e7eb 0 25%, transparent 0 50%, #e5e7eb 0 75%, transparent 0) 0 0/26px 26px; opacity:.7; display:none}
  #checker.on{display:block}
  #preview{position:absolute; inset:0; width:100%; height:100%; object-fit:contain; display:none}
  #textLayer{position:absolute; inset:0; pointer-events:none}

  .txt{
    position:absolute; left:140px; top:200px; max-width:360px;
    color:#111827; font-size:44px; font-weight:800; line-height:1.15;
    font-family:"Luckiest Guy", system-ui, sans-serif;
    white-space:pre-wrap; pointer-events:auto; cursor:move; user-select:none;
    -webkit-text-stroke:3px #ffffff; text-shadow:2px 2px 3px rgba(0,0,0,.15);
    transform-origin:left top; transform:rotate(0deg); padding:2px 4px; border-radius:10px
  }
  .txt.selected{ outline:2px solid #0ea5e9; box-shadow:0 0 0 3px rgba(14,165,233,.18) }

  /* Toast mini para mensajes */
  .toast{
    position:fixed; left:50%; bottom:20px; transform:translateX(-50%);
    background:#111827; color:#e5e7eb; padding:8px 12px; border-radius:10px;
    border:1px solid rgba(255,255,255,.12); box-shadow:0 8px 24px rgba(0,0,0,.35);
    font-size:13px; display:none; z-index:9999
  }
</style>
</head>
<body>
  <div class="shell">
    <div class="topbar">
      <button id="btnPick" class="btn ghost" title="Subir imagen">üì§ Subir</button>
      <input id="file" type="file" accept="image/*" style="display:none">
      <button id="btnAdd" class="btn primary" title="A√±adir texto">‚ûï Texto</button>
      <button id="btnStickerBorder" class="btn ghost" title="Contorno blanco fuerte para el texto seleccionado">‚¨ú Borde</button>
      <button id="btnRemoveBg" class="btn ok" title="Quitar fondo autom√°ticamente (protege el borde)">üßº Fondo</button>
      <button id="btnDownload" class="btn warn" title="Descargar PNG 1024√ó1024">‚¨áÔ∏è Descargar</button>
      <button id="btnClearAll" class="btn danger" title="Limpiar imagen y textos">üóëÔ∏è Limpiar</button>
    </div>

    <div class="stage-wrap">
      <div id="stage" tabindex="0">
        <div id="checker"></div>
        <img id="preview" alt="Imagen cargada">
        <div id="textLayer"></div>
      </div>
    </div>
  </div>

  <div id="toast" class="toast"></div>

<script>
  const $ = s => document.querySelector(s);
  const stage = $('#stage'), checker = $('#checker'), img = $('#preview'), layer = $('#textLayer');
  const file = $('#file');
  const btnPick = $('#btnPick'), btnAdd = $('#btnAdd'), btnStickerBorder = $('#btnStickerBorder');
  const btnRemoveBg = $('#btnRemoveBg'), btnDownload = $('#btnDownload'), btnClearAll = $('#btnClearAll');
  const toast = $('#toast');

  let active = null, imgLoaded = false, originalImgDataURL = null;

  // ---------- Utilidad mensajes
  function tip(msg, ms=1600){ toast.textContent = msg; toast.style.display='block'; setTimeout(()=> toast.style.display='none', ms); }

  // ---------- Imagen
  btnPick.onclick = () => file.click();
  file.onchange = e => {
    const f = e.target.files?.[0]; if(!f) return;
    const rd = new FileReader();
    rd.onload = ev => setImage(ev.target.result);
    rd.readAsDataURL(f);
  };
  ['dragenter','dragover','dragleave','drop'].forEach(ev => stage.addEventListener(ev, e=>{e.preventDefault(); e.stopPropagation();}));
  stage.addEventListener('drop', e=>{
    const f = e.dataTransfer.files?.[0];
    if(f && f.type.startsWith('image/')){
      const rd = new FileReader();
      rd.onload = ev => setImage(ev.target.result);
      rd.readAsDataURL(f);
    }
  });
  function setImage(src){
    img.src = src; img.style.display='block'; imgLoaded=true; originalImgDataURL = src;
    checker.classList.add('on'); tip('Imagen cargada');
  }

  // ---------- Textos
  function createText(){
    if(!imgLoaded){ tip('Primero sube una imagen'); return; }
    const el = document.createElement('div');
    el.className = 'txt';
    el.textContent = 'Nuevo texto';
    el.dataset.rot = '0';
    el.style.left = '140px';
    el.style.top  = '200px';
    el.style.maxWidth = '360px';
    layer.appendChild(el);
    select(el);
    tip('Texto a√±adido');
  }
  function select(el){
    if(active) active.classList.remove('selected');
    active = el;
    if(active) active.classList.add('selected');
  }
  btnAdd.onclick = createText;

  // Arrastrar con l√≠mites
  layer.addEventListener('pointerdown', e=>{
    if(!(e.target instanceof HTMLElement)) return;
    if(!e.target.classList.contains('txt')) return;
    select(e.target);
    const rect = layer.getBoundingClientRect();
    const sx = e.clientX, sy = e.clientY;
    const sL = parseFloat(active.style.left)||0, sT = parseFloat(active.style.top)||0;
    active.setPointerCapture(e.pointerId);
    function mv(ev){
      const dx = ev.clientX-sx, dy = ev.clientY-sy;
      const nx = clamp(sL+dx, 0, rect.width - active.offsetWidth);
      const ny = clamp(sT+dy, 0, rect.height - active.offsetHeight);
      active.style.left = nx+'px'; active.style.top = ny+'px';
    }
    function up(){ active.releasePointerCapture(e.pointerId); window.removeEventListener('pointermove',mv); window.removeEventListener('pointerup',up); }
    window.addEventListener('pointermove', mv);
    window.addEventListener('pointerup', up);
  });
  stage.addEventListener('pointerdown', e=>{
    if(e.target===stage || e.target===img || e.target===checker){
      if(active) active.classList.remove('selected'); active=null;
    }
  });
  // Atajos: mover y rotar
  window.addEventListener('keydown', e=>{
    if(!active) return;
    if(e.key==='Delete'){ active.remove(); active=null; tip('Texto borrado'); return; }
    const step = e.shiftKey ? 10 : 1;
    const L = parseFloat(active.style.left)||0, T = parseFloat(active.style.top)||0;
    if(e.key==='ArrowLeft'  && !e.ctrlKey){ active.style.left = clamp(L-step,0, layer.clientWidth-active.offsetWidth)+'px'; e.preventDefault(); }
    if(e.key==='ArrowRight' && !e.ctrlKey){ active.style.left = clamp(L+step,0, layer.clientWidth-active.offsetWidth)+'px'; e.preventDefault(); }
    if(e.key==='ArrowUp'){ active.style.top = clamp(T-step,0, layer.clientHeight-active.offsetHeight)+'px'; e.preventDefault(); }
    if(e.key==='ArrowDown'){ active.style.top = clamp(T+step,0, layer.clientHeight-active.offsetHeight)+'px'; e.preventDefault(); }
    if(e.ctrlKey && e.key==='ArrowLeft'){ setRotation(active, (parseFloat(active.dataset.rot||'0')-5)); e.preventDefault(); }
    if(e.ctrlKey && e.key==='ArrowRight'){ setRotation(active, (parseFloat(active.dataset.rot||'0')+5)); e.preventDefault(); }
  });
  function setRotation(el, deg){
    deg = clamp(deg, -180, 180);
    el.dataset.rot = String(deg);
    el.style.transform = `rotate(${deg}deg)`;
  }

  // Borde ‚Äúpegatina‚Äù r√°pido
  btnStickerBorder.onclick = () => {
    if(!active){ tip('Haz click en un texto primero'); return; }
    active.style['-webkit-text-stroke'] = `6px #ffffff`;
    active.style.textShadow = '2px 2px 3px rgba(0,0,0,.15)';
    tip('Borde aplicado');
  };

  // ---------- Quitar fondo (auto)
  // Detecta color predominante en los bordes y hace flood-fill con tolerancia segura.
  btnRemoveBg.onclick = async () => {
    if (!imgLoaded) return tip('Primero sube una imagen');
    const SAFE_EDGE = 2;   // protege contorno 2px
    const TOL = 25;        // tolerancia est√°ndar
    const size = 1024;

    const cvs = document.createElement('canvas'); cvs.width=cvs.height=size;
    const ctx = cvs.getContext('2d', { willReadFrequently:true });
    await drawContain(ctx, img, size, size);

    const data = ctx.getImageData(0,0,size,size);
    const px = data.data;
    const W=size, H=size, N=W*H;

    // 1) Color objetivo = color m√°s frecuente en los bordes
    const edgeColor = dominantEdgeColor(px, W, H);
    const [Tr, Tg, Tb] = edgeColor;

    // 2) Flood-fill desde los bordes
    const mask = new Uint8Array(N);
    const qx = new Uint32Array(N), qy = new Uint32Array(N);
    let qs=0, qe=0;
    const idx = (x,y)=> y*W + x;
    const isBg = (x,y)=>{
      const i=(y*W+x)*4; const r=px[i], g=px[i+1], b=px[i+2];
      return dist(r,g,b,Tr,Tg,Tb) <= TOL;
    };
    const push = (x,y)=>{ qx[qe]=x; qy[qe]=y; qe++; };
    const popX = ()=> qx[qs]; const popY = ()=> qy[qs++];

    for(let x=0;x<W;x++){ if(isBg(x,0)){ mask[idx(x,0)]=1; push(x,0);} if(isBg(x,H-1)){ mask[idx(x,H-1)]=1; push(x,H-1);} }
    for(let y=0;y<H;y++){ if(isBg(0,y)){ mask[idx(0,y)]=1; push(0,y);} if(isBg(W-1,y)){ mask[idx(W-1,y)]=1; push(W-1,y);} }

    while(qs<qe){
      const x=popX(), y=popY();
      if(x>0   && !mask[idx(x-1,y)] && isBg(x-1,y)){ mask[idx(x-1,y)]=1; push(x-1,y); }
      if(x<W-1 && !mask[idx(x+1,y)] && isBg(x+1,y)){ mask[idx(x+1,y)]=1; push(x+1,y); }
      if(y>0   && !mask[idx(x,y-1)] && isBg(x,y-1)){ mask[idx(x,y-1)]=1; push(x,y-1); }
      if(y<H-1 && !mask[idx(x,y+1)] && isBg(x,y+1)){ mask[idx(x,y+1)]=1; push(x,y+1); }
    }

    // 3) Protecci√≥n de borde para no ‚Äúmorder‚Äù el contorno del sticker
    for(let it=0; it<SAFE_EDGE; it++){
      const m2=new Uint8Array(N);
      for(let y=1;y<H-1;y++){
        for(let x=1;x<W-1;x++){
          const o=idx(x,y); if(!mask[o]) continue;
          if(mask[o-1] && mask[o+1] && mask[o-W] && mask[o+W]) m2[o]=1;
        }
      }
      // conservar el marco como qued√≥
      for(let x=0;x<W;x++){ if(mask[idx(x,0)]) m2[idx(x,0)]=1; if(mask[idx(x,H-1)]) m2[idx(x,H-1)]=1; }
      for(let y=0;y<H;y++){ if(mask[idx(0,y)]) m2[idx(0,y)]=1; if(mask[idx(W-1,y)]) m2[idx(W-1,y)]=1; }
      mask.set(m2);
    }

    // 4) Aplicar transparencia
    for(let i=0;i<N;i++){ if(mask[i]) px[i*4+3]=0; }
    ctx.putImageData(data,0,0);

    img.src = cvs.toDataURL('image/png');
    if(!originalImgDataURL) originalImgDataURL = img.src;
    checker.classList.add('on');
    tip('Fondo eliminado');
  };

  // ---------- Descargar (PNG 1024)
  btnDownload.onclick = async ()=>{
    if(!imgLoaded) return tip('Primero sube una imagen');
    const size = 1024, fmt = 'image/png';

    // aseg√∫rate de que las fuentes est√©n cargadas
    const loads = new Set();
    layer.querySelectorAll('.txt').forEach(el=>{
      const fs = parseInt(el.style.fontSize)||44;
      loads.add(document.fonts.load(`${el.style.fontStyle||'normal'} ${el.style.fontWeight||'700'} ${fs}px ${el.style.fontFamily||'Luckiest Guy'}`));
    });
    await Promise.all([...loads]);

    const cvs=document.createElement('canvas'); cvs.width=cvs.height=size;
    const ctx=cvs.getContext('2d'); ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high';
    ctx.lineJoin='round'; ctx.lineCap='round'; ctx.miterLimit=2;

    // fondo transparente (checker s√≥lo visual)
    await drawContain(ctx, img, size, size);

    const scale = size / layer.clientWidth;
    const nodes = [...layer.querySelectorAll('.txt')].sort((a,b)=>(+a.style.zIndex||0)-(+b.style.zIndex||0));
    for(const el of nodes){
      const fs=parseFloat(el.style.fontSize)||44;
      const fam=el.style.fontFamily||'Luckiest Guy';
      const weight=el.style.fontWeight||'700';
      const italic=el.style.fontStyle||'normal';
      const align=el.style.textAlign||'left';
      const deg=parseFloat(el.dataset.rot||'0')||0;
      const rad=deg*Math.PI/180;
      const x=parseFloat(el.style.left)||0;
      const y=parseFloat(el.style.top)||0;
      const maxW=parseFloat(el.style.maxWidth)||360;

      ctx.save();
      ctx.scale(scale,scale);
      ctx.translate(x,y);
      ctx.rotate(rad);
      ctx.font = `${italic} ${weight} ${fs}px ${fam}`;
      ctx.textBaseline='top';
      ctx.textAlign=align;

      let ax=0; if(align==='center') ax=maxW/2; if(align==='right') ax=maxW;

      const color = getComputedStyle(el).color;
      const [sw, sc] = parseStroke(getComputedStyle(el)['-webkit-text-stroke'] || '0px #ffffff');
      const hasShadow = (el.style.textShadow && el.style.textShadow!=='0 0 0 transparent');

      if(hasShadow){ ctx.shadowColor='rgba(0,0,0,.15)'; ctx.shadowBlur=3; ctx.shadowOffsetX=2; ctx.shadowOffsetY=2; }
      drawWrappedText(ctx, el.textContent, ax, 0, maxW, fs*1.15, color, sw, sc);
      ctx.restore();
    }

    const url=cvs.toDataURL(fmt);
    const a=document.createElement('a'); a.href=url; a.download='sticker_1024.png'; a.click();
  };

  // ---------- Limpiar
  btnClearAll.onclick = ()=>{
    img.removeAttribute('src'); img.style.display='none'; checker.classList.remove('on');
    layer.innerHTML=''; active=null; imgLoaded=false; originalImgDataURL=null;
    tip('Lienzo limpio');
  };

  // ---------- Utilidades
  function clamp(v,min,max){ return Math.min(Math.max(v,min),max) }
  function parseStroke(s){ const m=s.match(/([\d.]+)px\s+([#a-zA-Z0-9(),.\s]+)/); return m?[+m[1], m[2].trim()]:[0,'#ffffff']; }
  function dist(r,g,b,R,G,B){ return Math.hypot(r-R,g-G,b-B) }
  async function drawContain(ctx, imgEl, W, H){
    if(!imgEl.complete){ await new Promise(res=>{ imgEl.onload=()=>res(); imgEl.onerror=()=>res(); }); }
    const iw=imgEl.naturalWidth, ih=imgEl.naturalHeight, ir=iw/ih, cr=W/H; let dw,dh,dx,dy;
    if(ir>cr){ dw=W; dh=W/ir; dx=0; dy=(H-dh)/2; } else { dh=H; dw=H*ir; dy=0; dx=(W-dw)/2; }
    ctx.clearRect(0,0,W,H);
    ctx.drawImage(imgEl, dx,dy,dw,dh);
  }
  function drawWrappedText(ctx, text, x, y, maxW, lh, fillColor, strokeW, strokeColor){
    const words=(text||'').split(/\s+/); let line='', lines=[];
    for(let i=0;i<words.length;i++){ const test=line?line+' '+words[i]:words[i]; if(ctx.measureText(test).width<=maxW){ line=test; } else { if(line) lines.push(line); line=words[i]; } }
    if(line) lines.push(line);
    for(let i=0;i<lines.length;i++){
      const ly=y+i*lh;
      if(strokeW>0){ ctx.lineWidth=strokeW; ctx.strokeStyle=strokeColor; ctx.strokeText(lines[i], x, ly); }
      ctx.fillStyle=fillColor; ctx.fillText(lines[i], x, ly);
    }
  }
  // Color predominante en marco
  function dominantEdgeColor(px, W, H){
    const hist=new Map();
    const push = (i)=>{
      const r=px[i], g=px[i+1], b=px[i+2];
      const key=((r&0xF0)<<16)|((g&0xF0)<<8)|(b&0xF0); // cuantiza a 16 niveles
      hist.set(key, (hist.get(key)||0)+1);
    };
    for(let x=0;x<W;x++){ push((0*W + x)*4); push(((H-1)*W + x)*4); }
    for(let y=0;y<H;y++){ push((y*W + 0)*4); push((y*W + (W-1))*4); }
    let bestKey=0,bestCnt=-1;
    for(const [k,c] of hist.entries()){ if(c>bestCnt){ bestCnt=c; bestKey=k; } }
    const r=(bestKey>>16)&0xF0, g=(bestKey>>8)&0xF0, b=bestKey&0xF0;
    return [r, g, b];
  }
</script>
</body>
</html>
